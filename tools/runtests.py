#!/usr/bin/env python3

import os
import re
import sys
from glob import glob
from subprocess import check_output

MALWARE_PATH = 'malware'
RULES_PATH = 'rules'
RULES_CONFIRMED_PATH = RULES_PATH + '/all-confirmed.yar'
SEGMENTS = ['frontend', 'backend']

"""
Purpose: maintain quality of fingerprint database and malware corpus.

Ensure:

1. Every fingerprint has at least 1 match.
2. Every sample has at least 1 match.
3. Nothing from false-positives has a match
"""


def all_samples():
    return set([fn for s in SEGMENTS for fn in glob(MALWARE_PATH + '/' + s + '/*') ])


def slurp(path):
    with open(path) as fh:
        return fh.read()


def all_rules():
    
    rules = set()
    
    for segment in SEGMENTS:
        body = slurp(RULES_PATH + '/' + segment + '.yar') 
        rulenames = re.findall('rule\s+(\S+)\s', body)
        rules |= set(rulenames)
            
    
    return rules


def rule_skeleton(sample_path):
    md5 = sample_path.split('/')[-1]
    return """// %s
rule md5_%s {
    strings: $ = ""
    condition: any of them
}
""" % (sample_path, md5)
    


def runtests():
    report = check_output(['yara', '-r', RULES_CONFIRMED_PATH, MALWARE_PATH]).decode()
    
    rules = set([x.strip().partition(' ')[0] for x in report.splitlines()])
    samples = set([x.strip().partition(' ')[2] for x in report.splitlines()])
    
    unmatched_rules = all_rules() - rules
    unmatched_samples = all_samples() - samples
    
    if unmatched_rules:
        print("Found unmatched rules:")
        for x in sorted(unmatched_rules):
            print("\t" + x)
        
        
    if unmatched_samples:
        print("Found %s unmatched samples:\n" % len(unmatched_samples))
        for x in sorted(unmatched_samples):
            print(rule_skeleton(x))
#            print("\t" + x)
        
    if unmatched_rules or unmatched_samples:
        sys.exit(1)
    
    print("All tests succeeded")
    sys.exit(0)


if __name__ == '__main__':
    runtests()
